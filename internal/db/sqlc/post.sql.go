// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: post.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
  category_id
 ,title
 ,subtitle
 ,content
 ,publicated
) VALUES (
  $1,$2,$3,$4,$5
) RETURNING id, category_id, title, subtitle, content, publicated, created_at, updated_at
`

type CreatePostParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	Title      string    `json:"title"`
	Subtitle   string    `json:"subtitle"`
	Content    string    `json:"content"`
	Publicated bool      `json:"publicated"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.CategoryID,
		arg.Title,
		arg.Subtitle,
		arg.Content,
		arg.Publicated,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Title,
		&i.Subtitle,
		&i.Content,
		&i.Publicated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts
WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const getPostByCategoryPrivate = `-- name: GetPostByCategoryPrivate :many
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.content
      ,po.publicated
      ,po.category_id
      ,po.created_at
      ,po.updated_at
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id 
WHERE ca.id = $1
GROUP BY 1,2,3,4,5,6,7,8
`

type GetPostByCategoryPrivateRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	Content      string      `json:"content"`
	Publicated   bool        `json:"publicated"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) GetPostByCategoryPrivate(ctx context.Context, id uuid.UUID) ([]GetPostByCategoryPrivateRow, error) {
	rows, err := q.db.Query(ctx, getPostByCategoryPrivate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostByCategoryPrivateRow{}
	for rows.Next() {
		var i GetPostByCategoryPrivateRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.Content,
			&i.Publicated,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByCategoryPublic = `-- name: GetPostByCategoryPublic :many
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.content
      ,po.publicated
      ,po.category_id
      ,po.created_at
      ,po.updated_at
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id 
WHERE ca.id = $1
  AND po.publicated IS TRUE
GROUP BY 1,2,3,4,5,6,7,8
`

type GetPostByCategoryPublicRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	Content      string      `json:"content"`
	Publicated   bool        `json:"publicated"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) GetPostByCategoryPublic(ctx context.Context, id uuid.UUID) ([]GetPostByCategoryPublicRow, error) {
	rows, err := q.db.Query(ctx, getPostByCategoryPublic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostByCategoryPublicRow{}
	for rows.Next() {
		var i GetPostByCategoryPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.Content,
			&i.Publicated,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByIdPrivate = `-- name: GetPostByIdPrivate :one
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.content
      ,po.publicated
      ,po.category_id
      ,po.created_at
      ,po.updated_at
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id 
WHERE po.id = $1
GROUP BY 1,2,3,4,5,6,7,8
LIMIT 1
`

type GetPostByIdPrivateRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	Content      string      `json:"content"`
	Publicated   bool        `json:"publicated"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) GetPostByIdPrivate(ctx context.Context, id uuid.UUID) (GetPostByIdPrivateRow, error) {
	row := q.db.QueryRow(ctx, getPostByIdPrivate, id)
	var i GetPostByIdPrivateRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Subtitle,
		&i.Content,
		&i.Publicated,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.Tags,
	)
	return i, err
}

const getPostByIdPublic = `-- name: GetPostByIdPublic :one
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.content
      ,po.publicated
      ,po.category_id
      ,po.created_at
      ,po.updated_at
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name || "|" || ta.id) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id 
WHERE po.id = $1
  AND po.publicated IS TRUE
GROUP BY 1,2,3,4,5,6,7,8
LIMIT 1
`

type GetPostByIdPublicRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	Content      string      `json:"content"`
	Publicated   bool        `json:"publicated"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) GetPostByIdPublic(ctx context.Context, id uuid.UUID) (GetPostByIdPublicRow, error) {
	row := q.db.QueryRow(ctx, getPostByIdPublic, id)
	var i GetPostByIdPublicRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Subtitle,
		&i.Content,
		&i.Publicated,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.Tags,
	)
	return i, err
}

const getPostByTagPrivate = `-- name: GetPostByTagPrivate :many
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.content
      ,po.publicated
      ,po.category_id
      ,po.created_at
      ,po.updated_at
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id 
WHERE ta.id = $1
GROUP BY 1,2,3,4,5,6,7,8
`

type GetPostByTagPrivateRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	Content      string      `json:"content"`
	Publicated   bool        `json:"publicated"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) GetPostByTagPrivate(ctx context.Context, id uuid.UUID) ([]GetPostByTagPrivateRow, error) {
	rows, err := q.db.Query(ctx, getPostByTagPrivate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostByTagPrivateRow{}
	for rows.Next() {
		var i GetPostByTagPrivateRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.Content,
			&i.Publicated,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByTagPublic = `-- name: GetPostByTagPublic :many
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.content
      ,po.publicated
      ,po.category_id
      ,po.created_at
      ,po.updated_at
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id 
WHERE ta.id = $1
  AND po.publicated IS TRUE
GROUP BY 1,2,3,4,5,6,7,8
`

type GetPostByTagPublicRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	Content      string      `json:"content"`
	Publicated   bool        `json:"publicated"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) GetPostByTagPublic(ctx context.Context, id uuid.UUID) ([]GetPostByTagPublicRow, error) {
	rows, err := q.db.Query(ctx, getPostByTagPublic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostByTagPublicRow{}
	for rows.Next() {
		var i GetPostByTagPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.Content,
			&i.Publicated,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsPrivate = `-- name: ListPostsPrivate :many
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.created_at
      ,po.category_id
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id
GROUP BY 1,2,3,4,5,6
`

type ListPostsPrivateRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	CreatedAt    time.Time   `json:"created_at"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) ListPostsPrivate(ctx context.Context) ([]ListPostsPrivateRow, error) {
	rows, err := q.db.Query(ctx, listPostsPrivate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsPrivateRow{}
	for rows.Next() {
		var i ListPostsPrivateRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.CreatedAt,
			&i.CategoryID,
			&i.CategoryName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsPublic = `-- name: ListPostsPublic :many
SELECT po.id
      ,po.title
      ,po.subtitle
      ,po.created_at
      ,po.category_id
      ,ca.name AS category_name
      ,ARRAY_AGG(ta.name) AS tags
FROM posts AS po
JOIN categories AS ca ON po.category_id = ca.id
LEFT JOIN posts_tags AS pt ON pt.post_id = po.id
LEFT JOIN tags AS ta on pt.tag_id = ta.id
WHERE po.publicated IS TRUE
GROUP BY 1,2,3,4,5,6
`

type ListPostsPublicRow struct {
	ID           uuid.UUID   `json:"id"`
	Title        string      `json:"title"`
	Subtitle     string      `json:"subtitle"`
	CreatedAt    time.Time   `json:"created_at"`
	CategoryID   uuid.UUID   `json:"category_id"`
	CategoryName string      `json:"category_name"`
	Tags         interface{} `json:"tags"`
}

func (q *Queries) ListPostsPublic(ctx context.Context) ([]ListPostsPublicRow, error) {
	rows, err := q.db.Query(ctx, listPostsPublic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsPublicRow{}
	for rows.Next() {
		var i ListPostsPublicRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.CreatedAt,
			&i.CategoryID,
			&i.CategoryName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET
  title = COALESCE($1, title)
 ,subtitle = COALESCE($2, subtitle)
 ,content = COALESCE($3, content)
 ,publicated = COALESCE($4, publicated)
 ,category_id = COALESCE($5, category_id)
 ,updated_at = NOW()
WHERE
  id = $6
RETURNING id, category_id, title, subtitle, content, publicated, created_at, updated_at
`

type UpdatePostParams struct {
	Title      pgtype.Text `json:"title"`
	Subtitle   pgtype.Text `json:"subtitle"`
	Content    pgtype.Text `json:"content"`
	Publicated pgtype.Bool `json:"publicated"`
	CategoryID pgtype.UUID `json:"category_id"`
	ID         uuid.UUID   `json:"id"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.Title,
		arg.Subtitle,
		arg.Content,
		arg.Publicated,
		arg.CategoryID,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Title,
		&i.Subtitle,
		&i.Content,
		&i.Publicated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
